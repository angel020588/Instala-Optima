ndex.js (o app.js) â€“ archivo principal
require("dotenv").config();
const express = require("express");
const cors = require("cors");
const path = require("path");
const app = express();
const sequelize = require("./config/db");

// âœ… Middlewares necesarios
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true })); // <- NECESARIO para datos tipo x-www-form-urlencoded

// âœ… Servir frontend (si usas HTML)
app.use(express.static(path.join(__dirname, "public")));

// âœ… Evitar cachÃ© (opcional)
app.use((req, res, next) => {
  res.set("Cache-Control", "no-cache, no-store, must-revalidate");
  res.set("Pragma", "no-cache");
  res.set("Expires", "0");
  next();
});

// âœ… Rutas API
app.use("/api/esp32", require("./routes/esp32"));
app.use("/api/nivel", require("./routes/nivel"));
app.use("/api/cotizaciones", require("./routes/cotizaciones"));

// âœ… Ruta IA
app.post("/api/chat", async (req, res) => {
  const { mensaje, contexto } = req.body;

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "gpt-4",
      messages: [
        { role: "system", content: contexto },
        { role: "user", content: mensaje }
      ],
    })
  });

  const data = await response.json();
  res.json({ respuesta: data.choices?.[0]?.message?.content || "Error al generar respuesta." });
});

// âœ… Conectar DB y lanzar servidor
sequelize
  .sync({ alter: true })
  .then(() => {
    console.log("âœ… UltraBase conectada");
    app.listen(5000, "0.0.0.0", () => {
      console.log("ðŸš€ Servidor corriendo en puerto 5000");
    });
  })
  .catch((err) => {
    console.error("âŒ Error en UltraBase:", err);
  });

ðŸ“„ routes/esp32.js â€“ ruta para el ESP32
const express = require("express");
const router = express.Router();

// âœ… Ruta GET para pruebas desde navegador
router.get("/", (req, res) => {
  const nivel = parseInt(req.query.nivel);
  if (isNaN(nivel)) return res.status(400).send("nivel invÃ¡lido");

  console.log("ðŸ“¡ Nivel GET recibido:", nivel + "%");

  if (nivel <= 20) return res.send("encender");
  if (nivel >= 95) return res.send("apagar");
  return res.send("esperar");
});

// âœ… Ruta POST para peticiones reales desde ESP32
router.post("/", (req, res) => {
  const nivel = parseInt(req.body.nivel);
  const dispositivo = req.body.dispositivo || "ESP32";

  if (isNaN(nivel)) return res.status(400).json({ error: "Nivel invÃ¡lido" });

  console.log("ðŸ“¡ Nivel POST recibido:", nivel + "%", "Dispositivo:", dispositivo);

  let comando = "esperar";
  if (nivel <= 20) comando = "encender";
  else if (nivel >= 95) comando = "apagar";

  res.json({
    comando,
    nivel,
    mensaje: `Nivel ${nivel}% - ${comando} bomba`
  });
});

module.exports = router;

ðŸ§ª Pruebas
âœ… Desde navegador (GET)
https://instala-optima-ecotisat.replit.app/api/esp32?nivel=25


DeberÃ­as ver:

esperar

âœ… Desde consola (POST con curl)
curl -X POST https://instala-optima-ecotisat.replit.app/api/esp32 \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "nivel=50"


DeberÃ­as ver:

{
  "comando": "esperar",
  "nivel": 50,
  "mensaje": "Nivel 50% - esperar bomba"
}

âœ… Desde ESP32 (http.POST())

Ya puedes usar esta versiÃ³n:

HTTPClient http;
http.begin("https://instala-optima-ecotisat.replit.app/api/esp32");
http.addHeader("Content-Type", "application/x-www-form-urlencoded");

String postData = "nivel=" + String(porcentaje);
int httpResponseCode = http.POST(postData);

if (httpResponseCode > 0) {
  String respuesta = http.getString();
  Serial.println("Servidor respondiÃ³: " + respuesta);

  if (respuesta.indexOf("encender") >= 0) {
    digitalWrite(relayPin, LOW);
  } else if (respuesta.indexOf("apagar") >= 0) {
    digitalWrite(relayPin, HIGH);
  }
} else {
  Serial.print("Error HTTP: ");
  Serial.println(httpResponseCode);
}
http.end();

ðŸŸ¢ Resultado final

Con estos ajustes, tu ESP32 puede hacer POST correctamente a tu backend en Replit y recibir instrucciones como:

encender

apagar

esperar